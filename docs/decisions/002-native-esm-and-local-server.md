# Decision 002: 引入原生 ESM 和本地开发服务器

## 背景 (Context)

随着代码复杂度增加，单体 `index.js` 文件变得难以维护：
1. **面条代码**：数据逻辑、渲染逻辑、事件处理混在一起，超过 200 行。
2. **维护困难**：修改一个小功能需要滚动查看大量无关代码。
3. **重构风险**：拆分文件的需求变得迫切，但 `file://` 协议不支持 ESM。

## 决策 (Decision)

引入原生 ES Modules 和本地开发服务器，但**不引入打包工具**。

### 具体配置

1. **模块化**：使用 `<script type="module">` 和 `import/export` 语法。
2. **开发服务器**：安装 `five-server` 提供 HTTP 服务，解决 CORS 限制。
3. **文件拆分**：
   - `main.js`: 入口文件，负责初始化
   - `data.js`: 数据管理
   - `render.js`: UI 渲染逻辑
   - `events.js`: 事件处理

## 决策依据 (Rationale)

1. **最小复杂度**：相比引入 Webpack/Vite，只需要一个简单的 HTTP 服务器。
2. **架构透明**：保持"所写即所跑"，浏览器直接执行源码。
3. **渐进式演进**：从单体到模块化，无需改变运行时环境。

## 收益 (Positive)

1. **代码组织**：按职责拆分文件，提高可维护性。
2. **开发体验**：支持热重载，无需手动刷新浏览器。
3. **重构基础**：为后续 TypeScript 引入奠定模块化基础。

## 代价/约束 (Negative)

1. **协议限制**：必须使用 HTTP 服务器，无法双击 HTML 文件直接运行。
2. **依赖引入**：首次需要 `npm install` 和配置启动脚本。
3. **调试复杂度**：Network 面板显示多个文件请求。

## 替代方案 (Alternatives Considered)

- **打包工具**：能解决模块化问题，但引入过早的构建复杂度。
- **保持单体**：避免引入服务器，但代码维护性持续恶化。

## 结论

这是一个平衡的选择：在保持开发效率的同时，为未来的复杂度升级做好准备。