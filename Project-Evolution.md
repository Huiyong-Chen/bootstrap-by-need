# 📈 项目演进记录 (Project Evolution)

本文档记录本项目如何从“一无所有”逐步生长出“工程复杂度”的过程。
这里的每一个阶段，都对应着一次**架构师的思维转变**。

---

## Stage 1: 原生初开 (The Primitive Era)

> **时期**：项目启动 ~ 业务逻辑验证期  
> **核心哲学**：能跑就行，拒绝任何工具链。

### 🚨 遇到的痛点

1. 甚至不知道项目能不能做下去，不想配置 Webpack/Vite。
2. 需要极速验证想法，不想花时间装 `node_modules`。

### 🛠 解决方案

- **文件结构**：极简的 `index.html` + `index.css` + `index.js`。
- **运行方式**：双击 `index.html` 直接在浏览器打开。
- **数据管理**：硬编码在 JS 文件中。

### 📝 架构决策

- 🚫 **零依赖**：没有 `package.json`。
- 🚫 **零构建**：没有 Babel/TS，使用 ES5/ES6 浏览器原生支持的语法。

---

## Stage 2: 模块化觉醒 (The Module Awakening)

> **时期**：业务逻辑复杂化，代码行数突破舒适区  
> **核心哲学**：需要组织代码，但依然不想打包。

### 🚨 遇到的痛点

1. **面条代码**：所有逻辑（数据、DOM、事件）都塞在一个 `index.js` 里，修改极其困难。
2. **CORS 限制**：试图拆分文件使用 ES Modules (`import/export`) 时，浏览器因安全策略禁止 `file://` 协议加载模块。
3. **开发低效**：每次修改都要手动刷新浏览器 (F5)，打断心流。

### 🛠 解决方案

- **工程化雏形**：执行 `npm init`，引入 `package.json`。
- **引入 HTTP 服务**：安装 `five-server`，解决 `file://` 协议不支持 ESM 的问题。
- **原生模块化**：
  - 将单体脚本拆分为 `main.js` (入口), `data.js` (数据), `render.js` (视图)。
  - 在 HTML 中使用 `<script type="module">`。

### 📝 架构决策

- ✅ **引入 Dev Runtime**：仅引入开发阶段的运行时工具（Server）。
- 🚫 **坚持零构建**：依然没有 Webpack/Vite，浏览器直接执行源码。**所写即所跑**。
- ✅ **DX 提升**：实现了修改代码后的自动刷新（Live Reload）。

---

## Stage 3: 类型觉醒 (The Type Awakening)

> **时期**：多人协作前夕 / 数据结构变更频繁期  
> **核心哲学**：**运行时报错太慢，我要在保存时就报错。** 但依然坚持“所出即所行”（1 个 TS 输入 = 1 个 JS 输出）。

### 🚨 遇到的痛点

1.  **重构恐惧症**：修改一个公共接口（如 `User` 对象结构），不敢确定是否改完了所有引用的地方，导致运行时崩溃。
2.  **参数靠猜**：调用一个函数时，必须切换文件去阅读源码才能确定参数结构。
3.  **低级错误**：拼写错误或 `undefined` 访问在开发阶段无法被拦截。

### 🛠 解决方案

- **引入编译器**：安装 `typescript`，建立 `src` (源码) 与 `dist` (产物) 的目录映射。
- **类型约束**：将 `.js` 文件重命名为 `.ts`，开始定义 `interface` 和 `type`。
- **双进程开发**：
  - 进程 1: `tsc -w` 负责将 TS 转译为 JS。
  - 进程 2: `live-server` 负责监听 `dist/` 并刷新浏览器。

### 📝 架构决策

- ✅ **引入编译 (Compilation)**：这是项目第一次引入“非原生”语言，必须经过转译才能运行。
- 🚫 **拒绝打包 (No Bundling)**：依然没有 Webpack/Vite。
  - 架构师坚持在浏览器的 Network 面板看到真实的模块加载瀑布流，**不希望构建工具掩盖当前的性能真相**。
- ⚠️ **原生 ESM 的妥协**：为了让 TS 编译出的代码能被浏览器原生加载，在 `.ts` 源码中 `import` 必须显式写上 `.js` 后缀。

---

## Stage 4: 问题代码蓄意 (The Problem Code Stage)

> **时期**：TypeScript 引入后，代码复杂度快速增长期
> **核心哲学**：**故意引入问题代码，验证重构时机。**

### 🚨 遇到的痛点

1. **拼写错误泛滥**：函数名 `rolesSelectorRedner` 拼写错误，却在多个文件中使用。
2. **作用域混乱**：变量 `questionRatioList` 在事件监听器中使用，但定义在函数内部，导致潜在的 undefined 错误。
3. **代码冗余**：相同变量被重复初始化，增加了维护负担。
4. **职责混乱**：单个文件承担了 UI 渲染、数据处理、事件处理等多种职责，难以理解和维护。

### 🛠 解决方案

**故意保留问题代码**，记录当前状态，为后续重构做准备。

### 📝 架构决策

- ✅ **问题代码保留**：不立即修复问题，而是记录下来，作为重构必要性的证据。
- ✅ **状态记录**：通过 git 提交记录当前代码状态，便于后续对比重构效果。
- ⚠️ **重构准备**：确认这些问题确实需要解决，但暂不引入新工具，等待真实的重构需求。

### 💡 如何维护这份文档

每当你觉得“现在的开发模式太痛苦了”，并决定引入一个新工具（比如 TypeScript、Tailwind、Vite、Jest）时，请先在这里记录：

1. **痛点是什么？**
2. **为了解决它，你引入了什么？**

这比任何注释都更有价值。
