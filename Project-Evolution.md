# 📈 项目演进记录 (Project Evolution)

本文档记录本项目如何从"一无所有"逐步生长出"工程复杂度"的过程。
这里的每一个阶段，都对应着一次**架构师的思维转变**。

## 🏗️ 工程化里程碑总览

| 阶段        | 时间节点   | 核心成就   | 技术栈演进                             | 文档                                                                            |
| ----------- | ---------- | ---------- | -------------------------------------- | ------------------------------------------------------------------------------- |
| **Stage 1** | 项目启动   | 纯原生开发 | HTML + CSS + JS                        | [决策文档](./docs/decisions/001-initial-setup.md)                               |
| **Stage 2** | 业务复杂化 | ESM模块化  | `<script type="module">` + HTTP Server | [决策文档](./docs/decisions/002-native-esm-and-local-server.md)                 |
| **Stage 3** | 多人协作前 | 类型系统   | TypeScript + 手动编译                  | [决策文档](./docs/decisions/003-adopt-typescript-without-bundling.md)           |
| **Stage 4** | 重构准备   | 问题记录   | 故意保留问题代码                       | [决策文档](./docs/decisions/004-problem-code-stage.md)                          |
| **Stage 5** | 功能扩展   | 现代化架构 | 组件化 + IndexedDB + 分层架构          | [决策文档](./docs/decisions/005-architecture-refactor-and-feature-expansion.md) |
| **Stage 6** | 性能优化   | 构建工具链 | Vite + MPA + 代码分割                  | [决策文档](./docs/decisions/006-modern-build-architecture.md)                   |
| **Stage 7** | 质量管控   | 标准化体系 | ESLint + Prettier + Husky + Commitlint | [决策文档](./docs/decisions/007-quality-and-standardization.md)                 |

---

## 📖 详细阶段记录

## Stage 1: 原生初开 (The Primitive Era)

> **时期**：项目启动 ~ 业务逻辑验证期  
> **核心哲学**：能跑就行，拒绝任何工具链。

### 🚨 遇到的痛点

1. 甚至不知道项目能不能做下去，不想配置 Webpack/Vite。
2. 需要极速验证想法，不想花时间装 `node_modules`。

### 🛠 解决方案

- **文件结构**：极简的 `index.html` + `index.css` + `index.js`。
- **运行方式**：双击 `index.html` 直接在浏览器打开。
- **数据管理**：硬编码在 JS 文件中。

### 📝 架构决策

- 🚫 **零依赖**：没有 `package.json`。
- 🚫 **零构建**：没有 Babel/TS，使用 ES5/ES6 浏览器原生支持的语法。

---

## Stage 2: 模块化觉醒 (The Module Awakening)

> **时期**：业务逻辑复杂化，代码行数突破舒适区  
> **核心哲学**：需要组织代码，但依然不想打包。

### 🚨 遇到的痛点

1. **面条代码**：所有逻辑（数据、DOM、事件）都塞在一个 `index.js` 里，修改极其困难。
2. **CORS 限制**：试图拆分文件使用 ES Modules (`import/export`) 时，浏览器因安全策略禁止 `file://` 协议加载模块。
3. **开发低效**：每次修改都要手动刷新浏览器 (F5)，打断心流。

### 🛠 解决方案

- **工程化雏形**：执行 `npm init`，引入 `package.json`。
- **引入 HTTP 服务**：安装 `five-server`，解决 `file://` 协议不支持 ESM 的问题。
- **原生模块化**：
  - 将单体脚本拆分为 `main.js` (入口), `data.js` (数据), `render.js` (视图)。
  - 在 HTML 中使用 `<script type="module">`。

### 📝 架构决策

- ✅ **引入 Dev Runtime**：仅引入开发阶段的运行时工具（Server）。
- 🚫 **坚持零构建**：依然没有 Webpack/Vite，浏览器直接执行源码。**所写即所跑**。
- ✅ **DX 提升**：实现了修改代码后的自动刷新（Live Reload）。

---

## Stage 3: 类型觉醒 (The Type Awakening)

> **时期**：多人协作前夕 / 数据结构变更频繁期  
> **核心哲学**：**运行时报错太慢，我要在保存时就报错。** 但依然坚持“所出即所行”（1 个 TS 输入 = 1 个 JS 输出）。

### 🚨 遇到的痛点

1.  **重构恐惧症**：修改一个公共接口（如 `QuestionInfo` 对象结构），不敢确定是否改完了所有引用的地方，导致运行时崩溃。
2.  **参数靠猜**：调用一个函数时，必须切换文件去阅读源码才能确定参数结构。
3.  **低级错误**：拼写错误或 `undefined` 访问在开发阶段无法被拦截。

### 🛠 解决方案

- **引入编译器**：安装 `typescript`，建立 `src` (源码) 与 `dist` (产物) 的目录映射。
- **类型约束**：将 `.js` 文件重命名为 `.ts`，开始定义 `interface` 和 `type`。
- **多进程开发**：
  - 进程 1: `tsc -w` 负责将 TS 转译为 JS。
  - 进程 2: `live-server` 负责监听 `dist/` 并刷新浏览器。

### 📝 架构决策

- ✅ **引入编译 (Compilation)**：这是项目第一次引入“非原生”语言，必须经过转译才能运行。
- 🚫 **拒绝打包 (No Bundling)**：依然没有 Webpack/Vite。
  - 架构师坚持在浏览器的 Network 面板看到真实的模块加载瀑布流，**不希望构建工具掩盖当前的性能真相**。
- ⚠️ **原生 ESM 的妥协**：为了让 TS 编译出的代码能被浏览器原生加载，在 `.ts` 源码中 `import` 必须显式写上 `.js` 后缀。

---

## Stage 4: 问题代码蓄意 (The Problem Code Stage)

> **时期**：TypeScript 引入后，代码复杂度快速增长期
> **核心哲学**：**故意引入问题代码，验证重构时机。**

### 🚨 遇到的痛点

1. **作用域混乱**：变量 `questionRatioList` 在事件监听器中使用，但定义在函数内部。如果用户在初始化完成前与表单交互，会导致 undefined 错误。
2. **代码冗余**：`questionRatioList` 被重复初始化为空对象，增加了维护负担。
3. **职责混乱**：单个文件承担了 UI 渲染、数据处理、事件处理等多种职责，文件已超过 380 行，难以理解和维护。
4. **模块化不足**：尽管引入了 ESM，但组件间耦合度仍然较高。

### 🛠 解决方案

**故意保留问题代码**，记录当前状态，为后续重构做准备。

### 📝 架构决策

- ✅ **问题代码保留**：不立即修复问题，而是记录下来，作为重构必要性的证据。
- ✅ **状态记录**：通过 git 提交记录当前代码状态，便于后续对比重构效果。
- ⚠️ **重构准备**：确认这些问题确实需要解决，但暂不引入新工具，等待真实的重构需求。

---

## Stage 5: 架构重构与功能扩展 (Architecture Refactor & Feature Expansion)

> **时期**：代码复杂度失控，功能需求快速增长期
> **核心哲学**：**与其在泥潭中挣扎，不如重建家园。**

### 🚨 遇到的痛点

1. **文件职责混乱**：单文件超过380行，承担UI、数据、事件等多种职责。
2. **代码组织无序**：相关功能分散，难以理解和维护业务逻辑。
3. **功能单一**：只能随机生成题目，无法导入和管理题库。
4. **数据存储缺失**：题目数据无法持久化保存。
5. **导出功能空白**：生成的题目无法导出为标准文档格式。

### 🛠 解决方案

- **页面化架构**：拆分为home和import-questions两个独立页面。
- **组件化开发**：提取modal、roleSelector等可复用组件，采用JS生成DOM的方式实现。
- **分层架构**：建立表现层、组件层、业务层、数据层的清晰分层。
- **新功能特性**：题库导入、本地存储、文档导出功能。

#### 💭 组件实现方式的抉择

在组件实现方式上尝试了多种方案：

- **HTML-First**：通过template实现，DOM结构清晰但实现别扭
- **Web Components**：标准封装但过于复杂和重量级
- **JS生成DOM**：最终选择，与现有代码风格一致，实用性最高

### 📝 架构决策

- ✅ **全面重构**：从脚本文件结构转变为现代化的模块化架构。
- ✅ **功能扩展**：从原型工具转变为功能完整的应用。
- ✅ **数据持久化**：引入IndexedDB进行本地数据管理。
- ⚠️ **重构风险**：一次性大重构涉及大量文件变更。

### 📚 相关文档

- `docs/decisions/005-architecture-refactor-and-feature-expansion.md` - 架构重构决策详情（含组件实现策略）
- `docs/innerOS/005-architecture-refactor-pain-and-gains.md` - 重构过程的心路历程

---

## Stage 6: 现代构建架构 (Modern Build Architecture)

> **时期**：模块化拆分后，性能问题显现期
> **核心哲学**：**开发时的离散与运行时的聚合，必须通过工具链调和。**

### 🚨 遇到的痛点

1. **性能瓶颈**：HTTP 请求过多导致加载延迟（Network面板瀑布流嘲笑我们）。
2. **依赖债务**：第三方库（如 docx）手动管理困难且污染源码。
3. **规范限制**：原生 ESM 对文件后缀的限制导致开发体验不佳。

### 🛠 解决方案

- **构建工具革命**：引入 Vite 作为开发服务器和生产打包工具。
- **依赖管理迁移**：移除 `src/utils/` 下手动下载的库，全面接管至 `package.json`。
- **严格 ESM 规范**：将所有 TypeScript 源码后缀规范化为 `.mts`，配合自动化迁移脚本。
- **路径策略优化**：
  - `@` 别名用于 TS 模块（组件、工具函数）
  - 相对路径用于静态资源（CSS），确保IDE跳转正常

### 📝 架构决策

- ✅ **Vite 双模式**：Dev 模式保留 ESM 秒开体验；Prod 模式提供 Tree-shaking 和压缩优化。
- ✅ **NPM 生态接管**：源码体积大幅减小，依赖版本由 SemVer 管理。
- ✅ **自动化基建**：编写 `scripts/ts-to-mts.mts` 脚本，引入 `tsx` 和 `minimatch` 实现批量迁移。
- ✅ **MPA 配置**：明确 `index.html` 和 `import-questions.html` 两个入口，支持按页面打包。
- ⚠️ **复杂度提升**：引入 Node.js 环境依赖和构建配置，不再是"零配置"项目。

### 📊 优化成果

- **性能提升**：生产环境请求数从 ~50 降至 ~4（HTML+JS+CSS+Vendor）。
- **维护简化**：不需要再手动写 `.js` 后缀，依赖管理标准化。
- **基建赋能**：拥有了自定义工程脚本的能力，为未来自动化奠基。

### 💭 架构师的顿悟

**清晰度的代价**：Stage 5 的组件化重构虽然让代码井井有条，但物理法则很快找上门来——浏览器为了加载首页，不得不发起几十个 HTTP 请求。

**依赖的觉醒**：第一次打包时，`index.js` 竟然有一万多行。排查发现是因为手动下载的 `docx.js` 混在源码里。这一刻明白：**当依赖复杂到一定程度，手动管理就是一种债务。**

**自动化的开端**：面对几十个文件的重命名，编写了 `scripts/ts-to-mts.mts`。这标志着项目进入新阶段：**不再只是写业务代码，开始编写"维护代码的代码"。**

**配置的对齐**：别名 `@` 很好用，但它让 CSS 跳转失效了；`.mts` 很严谨，但工具链需要显式配置才能识别。**架构师的工作，很多时候就是找到不同工具配置之间的那个交集**。

### 📚 相关文档

- `docs/decisions/006-modern-build-architecture.md` - 现代构建架构决策详情
- `docs/innerOS/006-growing-pains-and-toolchains.md` - 工具链觉醒的心路历程

---

## Stage 7: 代码质量与标准化 (Quality & Standardization)

> **时期**：现代工具链完善后，代码质量管控期
> **核心哲学**：**秩序不再是负担，而是效率的基石。**

### 🚨 遇到的痛点

1. **语法冲突**：`.mts` 文件中泛型 `<T>` 被误识别为 JSX 标签。
2. **风格不一**：代码格式化不统一，影响团队协作。
3. **质量缺失**：缺少自动化检查，易引入低级错误。
4. **提交混乱**：Git 提交信息不规范，历史难以阅读。

### 🛠 解决方案

- **代码质量工具链**：引入 ESLint v9 (Flat Config) + Prettier，解决语法冲突和格式问题。
- **Git 钩子自动化**：配置 Husky + lint-staged，实现提交前自动检查和修复。
- **提交规范管控**：集成 Commitlint，确保 Git 历史可读性。
- **配置文件标准化**：使用 `.mts` 后缀统一配置语言，享受类型提示。

### 📝 架构决策

- ✅ **ESLint v9 Flat Config**：现代配置格式，内置 TypeScript 支持，解决 `.mts` 语法歧义。
- ✅ **Prettier 集成**：`trailingComma: "all"` 解决泛型冲突，统一代码风格。
- ✅ **自动化执法**：pre-commit 钩子拦截问题代码，commit-msg 校验提交格式。
- ✅ **类型安全配置**：所有配置文件使用 TypeScript，获得完整类型检查。
- ⚠️ **学习成本**：团队需要适应新的工作流和规范。

### 📊 优化成果

- **类型安全**：消除 `any` 类型，完善事件系统类型绑定。
- **代码一致性**：所有代码自动格式化，风格统一。
- **质量保障**：自动化拦截潜在 Bug 和不规范代码。
- **开发效率**：减少 Code Review 中的格式争论，专注业务逻辑。

### 💭 架构师的顿悟

**秩序的崩塌**：Stage 6 升级导致 `.mts` 语法冲突，原本隐蔽的问题暴露。认知负荷本该花在业务逻辑上，却消耗在分号和缩进上。

**代码即法律**：不是写在 Wiki 的规范文档，而是可执行的法律。Prettier 是排版工，ESLint 是检察官，Husky 是警察。

**执法与仪式感**：bad code 甚至没有资格进入暂存区。每次提交都是对代码库的郑重交付，必须清晰、规范、负责。

**从自律走向法治**：Stage 7 没有产出业务功能，却让项目从"能跑的草台班子"变成了"正规军"。

### 📚 相关文档

- `docs/decisions/007-quality-and-standardization.md` - 代码质量标准化决策详情
- `docs/innerOS/007-law-and-order.md` - 从自律走向法治的心路历程

---

## Stage 8: 终章与新生 (The End is The Beginning)

> **时期**：当工程化体系已完备，即将面临多平台分化抉择时
> **核心哲学**：**知道何时开始是一种智慧，知道何时结束是一种勇气。**

### 🚨 决策背景

项目目前的架构（Vite + TS + ESM + Lint）已经达到了单体应用的舒适区顶峰。
如果要继续演进（引入 React/Vue、服务端渲染、移动端路由），将不可避免地破坏当前架构的"纯粹性"，使其变得臃肿且难以作为通用参考。

### 🛠 最终决策

- **停止开发**：不再向此仓库添加任何业务功能。
- **封存状态**：保留当前的配置作为"黄金标准"（Golden Standard）。
- **架构升维**：将由此获得的经验（工程化规范、按需引入的思维模式）提取出来，注入到未来的 Monorepo 体系中。

### 💭 架构师的最后独白

我们往往沉迷于"做大做强"，却忘记了工程的初衷是解决问题。
这个项目从一个 `index.html` 开始，每一行配置都是为了减轻痛苦而生。
现在，它已经不痛了。它的使命完成了。

**它不是烂尾楼，它是地基。**
在此之上，我们将构建起官网、中后台与移动端的摩天大楼。

---

**[EOF] Project Evolution Recorded.**

### 💡 如何维护这份文档

每当你觉得"现在的开发模式太痛苦了"，并决定引入一个新工具（比如 TypeScript、Tailwind、Vite、Jest）时，请先在这里记录：

1. **痛点是什么？**
2. **为了解决它，你引入了什么？**

这比任何注释都更有价值。
