# 📈 项目演进记录 (Project Evolution)

本文档记录本项目如何从“一无所有”逐步生长出“工程复杂度”的过程。
这里的每一个阶段，都对应着一次**架构师的思维转变**。

---

## Stage 1: 原生初开 (The Primitive Era)

> **时期**：项目启动 ~ 业务逻辑验证期  
> **核心哲学**：能跑就行，拒绝任何工具链。

### 🚨 遇到的痛点

1. 甚至不知道项目能不能做下去，不想配置 Webpack/Vite。
2. 需要极速验证想法，不想花时间装 `node_modules`。

### 🛠 解决方案

- **文件结构**：极简的 `index.html` + `index.css` + `index.js`。
- **运行方式**：双击 `index.html` 直接在浏览器打开。
- **数据管理**：硬编码在 JS 文件中。

### 📝 架构决策

- 🚫 **零依赖**：没有 `package.json`。
- 🚫 **零构建**：没有 Babel/TS，使用 ES5/ES6 浏览器原生支持的语法。

---

## Stage 2: 模块化觉醒 (The Module Awakening)

> **时期**：业务逻辑复杂化，代码行数突破舒适区  
> **核心哲学**：需要组织代码，但依然不想打包。

### 🚨 遇到的痛点

1. **面条代码**：所有逻辑（数据、DOM、事件）都塞在一个 `index.js` 里，修改极其困难。
2. **CORS 限制**：试图拆分文件使用 ES Modules (`import/export`) 时，浏览器因安全策略禁止 `file://` 协议加载模块。
3. **开发低效**：每次修改都要手动刷新浏览器 (F5)，打断心流。

### 🛠 解决方案

- **工程化雏形**：执行 `npm init`，引入 `package.json`。
- **引入 HTTP 服务**：安装 `five-server`，解决 `file://` 协议不支持 ESM 的问题。
- **原生模块化**：
  - 将单体脚本拆分为 `main.js` (入口), `data.js` (数据), `render.js` (视图)。
  - 在 HTML 中使用 `<script type="module">`。

### 📝 架构决策

- ✅ **引入 Dev Runtime**：仅引入开发阶段的运行时工具（Server）。
- 🚫 **坚持零构建**：依然没有 Webpack/Vite，浏览器直接执行源码。**所写即所跑**。
- ✅ **DX 提升**：实现了修改代码后的自动刷新（Live Reload）。

---

## Stage 3: 类型觉醒 (The Type Awakening)

> **时期**：多人协作前夕 / 数据结构变更频繁期  
> **核心哲学**：**运行时报错太慢，我要在保存时就报错。** 但依然坚持“所出即所行”（1 个 TS 输入 = 1 个 JS 输出）。

### 🚨 遇到的痛点

1.  **重构恐惧症**：修改一个公共接口（如 `QuestionInfo` 对象结构），不敢确定是否改完了所有引用的地方，导致运行时崩溃。
2.  **参数靠猜**：调用一个函数时，必须切换文件去阅读源码才能确定参数结构。
3.  **低级错误**：拼写错误或 `undefined` 访问在开发阶段无法被拦截。

### 🛠 解决方案

- **引入编译器**：安装 `typescript`，建立 `src` (源码) 与 `dist` (产物) 的目录映射。
- **类型约束**：将 `.js` 文件重命名为 `.ts`，开始定义 `interface` 和 `type`。
- **多进程开发**：
  - 进程 1: `tsc -w` 负责将 TS 转译为 JS。
  - 进程 2: `live-server` 负责监听 `dist/` 并刷新浏览器。

### 📝 架构决策

- ✅ **引入编译 (Compilation)**：这是项目第一次引入“非原生”语言，必须经过转译才能运行。
- 🚫 **拒绝打包 (No Bundling)**：依然没有 Webpack/Vite。
  - 架构师坚持在浏览器的 Network 面板看到真实的模块加载瀑布流，**不希望构建工具掩盖当前的性能真相**。
- ⚠️ **原生 ESM 的妥协**：为了让 TS 编译出的代码能被浏览器原生加载，在 `.ts` 源码中 `import` 必须显式写上 `.js` 后缀。

---

## Stage 4: 问题代码蓄意 (The Problem Code Stage)

> **时期**：TypeScript 引入后，代码复杂度快速增长期
> **核心哲学**：**故意引入问题代码，验证重构时机。**

### 🚨 遇到的痛点

1. **作用域混乱**：变量 `questionRatioList` 在事件监听器中使用，但定义在函数内部。如果用户在初始化完成前与表单交互，会导致 undefined 错误。
2. **代码冗余**：`questionRatioList` 被重复初始化为空对象，增加了维护负担。
3. **职责混乱**：单个文件承担了 UI 渲染、数据处理、事件处理等多种职责，文件已超过 380 行，难以理解和维护。
4. **模块化不足**：尽管引入了 ESM，但组件间耦合度仍然较高。

### 🛠 解决方案

**故意保留问题代码**，记录当前状态，为后续重构做准备。

### 📝 架构决策

- ✅ **问题代码保留**：不立即修复问题，而是记录下来，作为重构必要性的证据。
- ✅ **状态记录**：通过 git 提交记录当前代码状态，便于后续对比重构效果。
- ⚠️ **重构准备**：确认这些问题确实需要解决，但暂不引入新工具，等待真实的重构需求。

---

## Stage 5: 架构重构与功能扩展 (Architecture Refactor & Feature Expansion)

> **时期**：代码复杂度失控，功能需求快速增长期
> **核心哲学**：**与其在泥潭中挣扎，不如重建家园。**

### 🚨 遇到的痛点

1. **文件职责混乱**：单文件超过380行，承担UI、数据、事件等多种职责。
2. **代码组织无序**：相关功能分散，难以理解和维护业务逻辑。
3. **功能单一**：只能随机生成题目，无法导入和管理题库。
4. **数据存储缺失**：题目数据无法持久化保存。
5. **导出功能空白**：生成的题目无法导出为标准文档格式。

### 🛠 解决方案

- **页面化架构**：拆分为home和import-questions两个独立页面。
- **组件化开发**：提取modal、roleSelector等可复用组件，采用JS生成DOM的方式实现。
- **分层架构**：建立表现层、组件层、业务层、数据层的清晰分层。
- **新功能特性**：题库导入、本地存储、文档导出功能。

#### 💭 组件实现方式的抉择

在组件实现方式上尝试了多种方案：

- **HTML-First**：通过template实现，DOM结构清晰但实现别扭
- **Web Components**：标准封装但过于复杂和重量级
- **JS生成DOM**：最终选择，与现有代码风格一致，实用性最高

### 📝 架构决策

- ✅ **全面重构**：从脚本文件结构转变为现代化的模块化架构。
- ✅ **功能扩展**：从原型工具转变为功能完整的应用。
- ✅ **数据持久化**：引入IndexedDB进行本地数据管理。
- ⚠️ **重构风险**：一次性大重构涉及大量文件变更。

### 📚 相关文档

- `docs/decisions/005-architecture-refactor-and-feature-expansion.md` - 架构重构决策详情（含组件实现策略）
- `docs/innerOS/005-architecture-refactor-pain-and-gains.md` - 重构过程的心路历程

### 💡 如何维护这份文档

每当你觉得"现在的开发模式太痛苦了"，并决定引入一个新工具（比如 TypeScript、Tailwind、Vite、Jest）时，请先在这里记录：

1. **痛点是什么？**
2. **为了解决它，你引入了什么？**

这比任何注释都更有价值。
